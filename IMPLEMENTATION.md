This file describe technical information on the internal processing of this python programm.  
*Note :*
1. some of these procedure has already been implemented, other, not.
2. In this text, we coufound the actual SQL table to its csv-file equivalent. However, it is important to remember that this programm works with csv dumps of SQL tables.

## The main idea
What we want is to produce xAPI json file statements from events generated by Moodle. As described by the [official moodle documentation](https://docs.moodle.org/dev/Events_API) : 
> Events are atomic pieces of information describing something that happened in Moodle.

The main culprit to do this operation is a table `mdl_logstore_standard_log` generated by the logstore moodle plugin (activated by default). Indeed, every row of this table exactly describe one event that happened (with each column corresponding to an [event property](https://docs.moodle.org/dev/Events_API#Properties)). As such the main function of this python script is just to iterate and 'process' every row of this `mdl_logstore_standard_log` table.

## Processing the table
This program uses the python [`csv`](https://docs.python.org/3/library/csv.html) module to process row by row the `mdl_logstore_standard_log` table.
We go by a few step on how to process one row of this table :

### **1. Filtering**
Since we are only intrested in the user experience of a student, the program first check if the `edulevel` field of the row is equal to 2. Indeed, this way we know that the event is directly tied to a learning experience (see [Level property](https://docs.moodle.org/dev/Events_API#Level_property)).  
Next, we perform a check on the `eventname` field. The `xapi_resouces.py` file contains an `event_list` dictionary. If the `eventname` is present as a key in this dictionary, then program get the associated value, representing which type of xAPI statement will be produced. for example, the `eventname "\mod_resource\event\course_module_viewed"` is a key to `"viewed"` in this dictionnary. The function then call the proper function from `statements.py` that should process to make the statement off this row. In our example, the python program would call the `statement.make_viewed function`

### **2. Making the statement out of the row**
As described in each function's documentation, the `make` functions in the `statements` module will return a None object if the proccessing failed, and a Tincan statement object if the row was proprely processed.

#### **2.1 Generating the actor**
Each xAPI statement need an actor object. For this we simply generate an actor object with solely a mailbox IRI formatted :  
`mailto:<userid>@<url_of_the_moodle>`. The url_of_the_moodle is located and defined in the [config file](app_xapi/config.py)

#### **2.2 Making viewed statements**
For each row that are processed by the `statements.make_viewed` function, we first check if the `"objecttable"` field is `"NULL"` or not. If so, we check if the corresponding event is `"\core\event\course_viewed"`. This way we know that have an event corresponding to viewing a course (which will then be our xAPI object). Fortunately, the `courseid` field gives us the id of the corresponding course in the `course` table (located in the moodle database). We build an IRI of that (see directly the [`make_viewed` function in statements.py](app_xapi/statements.py)) to make the object IRI.  
If `"objecttable"` field is `"NULL"` but the eventname does not correspond, we return `None` ; the event is not handled by the python program.  
If otherwise the `"objecttable"` field is not `"NULL"`, that means we are looking at a module or object inside a course. As such, following our xAPI profile, we have to build a Tincan context object with a parent in the ContextActivities field, containing the course as a parent. In addition we also build an IRI of the object being viewed off the `objecttable` and `objectid`.

#### **2.3 Making completed statements** 
The event tied to module completion is `"\core\event\course_module_completion_updated"`. However, this event only tracks if completion state was updated - not if it was indeed completed. To remedy this, we use the `objectid` as a primary key in the `course_modules_completion` table to look the `completionstate` value. Only once we're sure that the `"\core\event\course_module_completion_updated"` correspond to a `completionstate` of 1, we process the event (else, the function returns `None`).
Since the completed statement only describes module completion, we already know that the statement has a course object present in the ContextActivities field as a parent. As such, each row that are processed by the `statements.make_completed` builds the course as a parent in the same way that `statements.make_viewed` does. To build the correct Tincan object, we have to do jump into many tables ; we first have to fetch the `coursemoduleid` in the `mdl_course_modules_completion`, from there  using the `coursemoduleid`, we fetch info in the `mdl_course_modules` and `mdl_modules` tables to build similar object IRI produced by the `statements.make_viewed` function (the `instance` field in the `mdl_course_modules` correspond to the id of the object, and the `module` field in the same table is used as a primary key in the `mdl_modules` table to fetch the proper name object)

#### **2.4 Making answered statements**